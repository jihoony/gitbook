# An Overview of Identifiers in Hibernate/JPA

### 1. Overview

Identifiers in Hibernate represent the primary key of an entity. This implies the values are unique so that they can identify a specific entity, that they aren’t null and that they won’t be modified.

Hibernate provides a few different ways to define identifiers. In this article, we’ll review each method of mapping entity ids using the library.

### **2. Simple Identifiers** <a href="#bd-simple-identifiers" id="bd-simple-identifiers"></a>

The most straightforward way to define an identifier is by using the _@Id_ annotation.

Simple ids are mapped using _@Id_ to a single property of one of these types: Java primitive and primitive wrapper types, _String_, _Date_, _BigDecimal_ and _BigInteger_.

Let’s see a quick example of defining an entity with a primary key of type _long_:

```java
@Entity
public class Student {

    @Id
    private long studentId;
    
    // standard constructor, getters, setters
}
```

### **3. Generated Identifiers** <a href="#bd-generated-identifiers" id="bd-generated-identifiers"></a>

If we want to automatically generate the primary key value, **we can add the&#x20;**_**@GeneratedValue**_**&#x20;annotation.**

This can use four generation types: AUTO, IDENTITY, SEQUENCE and TABLE.

If we don’t explicitly specify a value, the generation type defaults to AUTO.

#### **3.1.&#x20;**_**AUTO**_**&#x20;Generation** <a href="#bd-1-auto-generation" id="bd-1-auto-generation"></a>

If we’re using the default generation type, the persistence provider will determine values based on the type of the primary key attribute. This type can be numerical or _UUID_.

For numeric values, the generation is based on a sequence or table generator, while _UUID_ values will use the _UUIDGenerator_.

Let’s first map an entity primary key using AUTO generation strategy:

```java
@Entity
public class Student {

    @Id
    @GeneratedValue
    private long studentId;

    // ...
}
```

In this case, the primary key values will be unique at the database level.

**Now we’ll look at the&#x20;**_**UUIDGenerator**_**, which was introduced in Hibernate 5.**

In order to use this feature, we just need to declare an id of type _UUID_ with _@GeneratedValue_ annotation:

```java
@Entity
public class Course {

    @Id
    @GeneratedValue
    private UUID courseId;

    // ...
}
```

Hibernate will generate an id of the form “8dd5f315-9788-4d00-87bb-10eed9eff566”.

#### **3.2.&#x20;**_**IDENTITY**_**&#x20;Generation** <a href="#bd-2-identity-generation" id="bd-2-identity-generation"></a>

This type of generation relies on the _IdentityGenerator_, which expects values generated by an _identity_ column in the database. This means they are auto-incremented.

To use this generation type, we only need to set the _strategy_ parameter:

```java
@Entity
public class Student {

    @Id
    @GeneratedValue (strategy = GenerationType.IDENTITY)
    private long studentId;

    // ...
}
```

One thing to note is that IDENTITY generation disables batch updates.

#### **3.3.&#x20;**_**SEQUENCE**_**&#x20;Generation** <a href="#bd-3-sequence-generation" id="bd-3-sequence-generation"></a>

To use a sequence-based id, Hibernate provides the _SequenceStyleGenerator_ class.

This generator uses sequences if our database supports them. It switches to table generation if they aren’t supported.

In order to customize the sequence name, we can use the _@GenericGenerator_ annotation with _SequenceStyleGenerator strategy_:

```java
@Entity
public class User {
    @Id
    @GeneratedValue(generator = "sequence-generator")
    @GenericGenerator(
      name = "sequence-generator",
      strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
      parameters = {
        @Parameter(name = "sequence_name", value = "user_sequence"),
        @Parameter(name = "initial_value", value = "4"),
        @Parameter(name = "increment_size", value = "1")
        }
    )
    private long userId;
    
    // ...
}
```

In this example, we’ve also set an initial value for the sequence, which means the primary key generation will start at 4.

_SEQUENCE_ is the generation type recommended by the Hibernate documentation.

**The generated values are unique per sequence.** If we don’t specify a sequence name, Hibernate will reuse the same _hibernate\_sequence_ for different types.

#### **3.4. TABLE Generation** <a href="#bd-4-table-generation" id="bd-4-table-generation"></a>

The _TableGenerator_ uses an underlying database table that holds segments of identifier generation values.

Let’s customize the table name using the _@TableGenerator_ annotation:

```java
@Entity
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, 
      generator = "table-generator")
    @TableGenerator(name = "table-generator", 
      table = "dep_ids", 
      pkColumnName = "seq_id", 
      valueColumnName = "seq_value")
    private long depId;

    // ...
}
```

In this example, we can see that we can also customize other attributes such as the _pkColumnName_ and _valueColumnName_.

However, the disadvantage of this method is that it doesn’t scale well and can negatively affect performance.

**To sum up, these four generation types will result in similar values being generated but use different database mechanisms.**

#### **3.5. Custom Generator** <a href="#bd-5-custom-generator" id="bd-5-custom-generator"></a>

Let’s say we don’t want to use any of the out-of-the-box strategies. In order to do that, **we can define our custom generator by implementing the&#x20;**_**IdentifierGenerator**_**&#x20;interface.**

We’ll create a generator that builds identifiers containing a _String_ prefix and a number:

```java
public class MyGenerator 
  implements IdentifierGenerator, Configurable {

    private String prefix;

    @Override
    public Serializable generate(
      SharedSessionContractImplementor session, Object obj) 
      throws HibernateException {

        String query = String.format("select %s from %s", 
            session.getEntityPersister(obj.getClass().getName(), obj)
              .getIdentifierPropertyName(),
            obj.getClass().getSimpleName());

        Stream ids = session.createQuery(query).stream();

        Long max = ids.map(o -> o.replace(prefix + "-", ""))
          .mapToLong(Long::parseLong)
          .max()
          .orElse(0L);

        return prefix + "-" + (max + 1);
    }

    @Override
    public void configure(Type type, Properties properties, 
      ServiceRegistry serviceRegistry) throws MappingException {
        prefix = properties.getProperty("prefix");
    }
}
```

In this example, **we override the&#x20;**_**generate()**_**&#x20;method from the&#x20;**_**IdentifierGenerator**_**&#x20;interface.**

First, we want to find the highest number from the existing primary keys of the form _prefix-XX_. Then we add 1 to the maximum number found and append the _prefix_ property to get the newly generated id value.

Our class also implements the _Configurable_ interface so that we can set the _prefix_ property value in the _configure()_ method.

Next, let’s add this custom generator to an entity.

For this, **we can use the&#x20;**_**@GenericGenerator**_**&#x20;annotation with a&#x20;**_**strategy**_**&#x20;parameter that contains the full class name of our generator class**:

```java
@Entity
public class Product {

    @Id
    @GeneratedValue(generator = "prod-generator")
    @GenericGenerator(name = "prod-generator", 
      parameters = @Parameter(name = "prefix", value = "prod"), 
      strategy = "com.baeldung.hibernate.pojo.generator.MyGenerator")
    private String prodId;

    // ...
}
```

Also, notice we’ve set the prefix parameter to “prod”.

Let’s see a quick JUnit test for a clearer understanding of the id values generated:

```java
@Test
public void whenSaveCustomGeneratedId_thenOk() {
    Product product = new Product();
    session.save(product);
    Product product2 = new Product();
    session.save(product2);

    assertThat(product2.getProdId()).isEqualTo("prod-2");
}
```

Here the first value generated using the “prod” prefix was “prod-1”, followed by “prod-2”.

### **4. Composite Identifiers** <a href="#bd-composite-identifiers" id="bd-composite-identifiers"></a>

Besides the simple identifiers we’ve seen so far, Hibernate also allows us to define composite identifiers.

A composite id is represented by a primary key class with one or more persistent attributes.

**The primary key class must fulfil several conditions**:

* It should be defined using _@EmbeddedId_ or _@IdClass_ annotations.
* It should be public, serializable and have a public no-arg constructor.
* Finally, it should implement _equals()_ and _hashCode()_ methods.

The class’s attributes can be basic, composite or ManyToOne, while avoiding collections and _OneToOne_ attributes.

#### **4.1.&#x20;**_**@EmbeddedId**_ <a href="#bd-1-embeddedid" id="bd-1-embeddedid"></a>

Now let’s look at how to define an id using _@EmbeddedId_.

First, we need a primary key class annotated with _@Embeddable_:

```java
@Embeddable
public class OrderEntryPK implements Serializable {

    private long orderId;
    private long productId;

    // standard constructor, getters, setters
    // equals() and hashCode() 
}
```

Next, we can add an id of type _OrderEntryPK_ to an entity using @_EmbeddedId_:

```java
@Entity
public class OrderEntry {

    @EmbeddedId
    private OrderEntryPK entryId;

    // ...
}
```

Let’s see how we can use this type of composite id to set the primary key for an entity:

```java
@Test
public void whenSaveCompositeIdEntity_thenOk() {
    OrderEntryPK entryPK = new OrderEntryPK();
    entryPK.setOrderId(1L);
    entryPK.setProductId(30L);
        
    OrderEntry entry = new OrderEntry();
    entry.setEntryId(entryPK);
    session.save(entry);

    assertThat(entry.getEntryId().getOrderId()).isEqualTo(1L);
}
```

Here the _OrderEntry_ object has an _OrderEntryPK_ primary id formed of two attributes: _orderId_ and _productId_.

#### **4.2.&#x20;**_**@IdClass**_ <a href="#bd-2-idclass" id="bd-2-idclass"></a>

The _@IdClass_ annotation is similar to the _@EmbeddedId_. The difference with _@IdClass_ is that the attributes are defined in the main entity class using _@Id_ for each one. The primary key class will look the same as before.

Let’s rewrite the _OrderEntry_ example with an _@IdClass_:

```java
@Entity
@IdClass(OrderEntryPK.class)
public class OrderEntry {
    @Id
    private long orderId;
    @Id
    private long productId;
    
    // ...
}
```

Then we can set the id values directly on the _OrderEntry_ object:

```java
@Test
public void whenSaveIdClassEntity_thenOk() {        
    OrderEntry entry = new OrderEntry();
    entry.setOrderId(1L);
    entry.setProductId(30L);
    session.save(entry);

    assertThat(entry.getOrderId()).isEqualTo(1L);
}
```

Note that for both types of composite ids, the primary key class can also contain _@ManyToOne_ attributes:

```java
@Embeddable
public class OrderEntryPK implements Serializable {

    private long orderId;
    private long productId;
    @ManyToOne
    private User user;

    // ...
}
```

```java
@Entity
@IdClass(OrderEntryPK.class)
public class OrderEntryIdClass {
    @Id
    private long orderId;
    @Id
    private long productId;
    @ManyToOne
    private User user;

    // ...
}
```

Hibernate also allows defining primary keys made up of _@ManyToOne_ associations combined with _@Id_ annotation. In this case, the entity class should also fulfil the conditions of a primary key class.

However, the disadvantage of this method is that there’s no separation between the entity object and the identifier.

### **5. Derived Identifiers** <a href="#bd-derived-identifiers" id="bd-derived-identifiers"></a>

Derived identifiers are obtained from an entity’s association using the _@MapsId_ annotation.

First, let’s create a _UserProfile_ entity that derives its id from a one-to-one association with the _User_ entity:

```java
@Entity
public class UserProfile {

    @Id
    private long profileId;
    
    @OneToOne
    @MapsId
    private User user;

    // ...
}
```

Next, let’s verify that a _UserProfile_ instance has the same id as its associated _User_ instance:

```java
@Test
public void whenSaveDerivedIdEntity_thenOk() {        
    User user = new User();
    session.save(user);
       
    UserProfile profile = new UserProfile();
    profile.setUser(user);
    session.save(profile);

    assertThat(profile.getProfileId()).isEqualTo(user.getUserId());
}
```

### **6. Conclusion** <a href="#bd-conclusion" id="bd-conclusion"></a>

In this article, we’ve seen the multiple ways we can define identifiers in Hibernate.

The full source code of the examples can be found [over on GitHub](https://github.com/eugenp/tutorials/tree/master/persistence-modules/hibernate5).



{% embed url="https://www.baeldung.com/hibernate-identifiers" %}
